Федеральное государственное автономное образовательной учреждение

высшего образования

**НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ**

**«ВЫСШАЯ ШКОЛА ЭКОНОМИКИ»**

**Московский институт электроники и математики имени А. Н. Тихонова**

## Ханойская башня

**Семинар №2**

**по дисциплине "Языки программирования"**

Студент группы СКБ241 - Авакян Арман Арменович

Преподаватель - Рогачёва Ольга Алексеевна

---

## Описание программы

Данная программа реализует классическую головоломку **"Ханойская башня"** на языке C++. Пользователь может самостоятельно играть, перемещая кольца между стержнями, следуя правилам игры. Программа демонстрирует применение основных концепций программирования, включая **определение функций**, **рекурсию** и **анализ сложности алгоритмов**, строго соответствуя представленным статьям и описаниям.

---

## Содержание

- [Описание игры](#описание-игры)
- [Правила игры](#правила-игры)
- [Структура программы](#структура-программы)
- [Используемые функции](#используемые-функции)
  - [Определение функций](#определение-функций)
  - [Рекурсивная функция `hanoiRecursive`](#рекурсивная-функция-hanoirecursive)
- [Сложность алгоритма](#сложность-алгоритма)
- [Пример работы программы](#пример-работы-программы)
- [Заключение](#заключение)
- [Ссылки на используемые материалы](#ссылки-на-используемые-материалы)

---

## Описание игры

**Ханойская башня** — это математическая головоломка, состоящая из трех стержней и нескольких дисков различного диаметра, которые можно надевать на стержни. Изначально все диски надеты на первый стержень в порядке убывания диаметра — от большего внизу до меньшего наверху, образуя конусообразную башню.

Цель игры — переместить всю башню с первого стержня на третий, следуя определенным правилам.

---

## Правила игры

- **Перемещать можно только по одному диску за раз.**
- **Нельзя помещать больший диск на меньший.**
- **Можно использовать промежуточный (второй) стержень для временного хранения дисков.**

---

## Структура программы

Программа состоит из нескольких функций, каждая из которых выполняет определенную задачу:

1. **`main()`**: Основная функция, управляющая игровым процессом.
2. **`hanoiRecursive()`**: Рекурсивная функция для вычисления оптимального решения.
3. **`displayTowers()`**: Функция для отображения текущего состояния стержней.
4. **`makeMove()`**: Функция для выполнения хода игрока.
5. **`isGameWon()`**: Функция для проверки победы.

---

## Используемые функции

### Определение функций

Согласно статье **"Определение функции"**, функция определяется следующим образом:

```cpp
тип имя_функции(параметры) {
    // инструкции
}
```

В программе все функции определены в соответствии с этим синтаксисом.

**Пример определения функции `displayTowers`:**

```cpp
void displayTowers(const std::vector<std::stack<int>>& towers, int num_disks) {
    // Тело функции
}
```

### Рекурсивная функция `hanoiRecursive`

Рекурсивная функция `hanoiRecursive` вычисляет оптимальную последовательность перемещений для решения головоломки.

**Сигнатура функции:**

```cpp
void hanoiRecursive(int n, int from_rod, int to_rod, int aux_rod, std::vector<std::pair<int, int>>& moves);
```

**Описание параметров:**

- `n`: Количество дисков.
- `from_rod`: Стержень, с которого нужно переместить диски.
- `to_rod`: Стержень, на который нужно переместить диски.
- `aux_rod`: Вспомогательный стержень.
- `moves`: Вектор для хранения оптимальной последовательности ходов.

**Логика функции:**

- **Базовый случай рекурсии:** Если `n == 1`, переместить диск с `from_rod` на `to_rod`.
  
  ```cpp
  if (n == 1) {
      moves.push_back({from_rod, to_rod});
      return;
  }
  ```

- **Рекурсивные вызовы:**
  
  - Переместить `n-1` дисков с `from_rod` на `aux_rod`, используя `to_rod` как вспомогательный.
    
    ```cpp
    hanoiRecursive(n - 1, from_rod, aux_rod, to_rod, moves);
    ```
  
  - Переместить оставшийся диск с `from_rod` на `to_rod`.
    
    ```cpp
    moves.push_back({from_rod, to_rod});
    ```
  
  - Переместить `n-1` дисков с `aux_rod` на `to_rod`, используя `from_rod` как вспомогательный.
    
    ```cpp
    hanoiRecursive(n - 1, aux_rod, to_rod, from_rod, moves);
    ```

**Пример вызова функции:**

```cpp
std::vector<std::pair<int, int>> optimalMoves;
hanoiRecursive(n, 1, 3, 2, optimalMoves);
```

---

## Сложность алгоритма

Согласно статье **"Сложность алгоритмов. Разбор Big O"**, алгоритм решения Ханойской башни имеет **экспоненциальную сложность** `O(2^n)`.

- **Причина экспоненциальной сложности:** Каждый диск требует перемещения, которое зависит от перемещения всех меньших дисков, что приводит к экспоненциальному росту количества операций при увеличении `n`.

**График сложности:**

![График сложности O(2^n)](https://habrastorage.org/r/w1560/getpro/habr/upload_files/973/455/cf3/973455cf3bb354f49113562838372900.jpg)

*График экспоненциальной функции, демонстрирующий быстрое увеличение времени выполнения алгоритма с ростом `n`.*

---

## Пример работы программы

**Запуск программы с 3 дисками:**

```
Выбор размера игры:

3 4 5
6 7 8

Введите количество колец (3-8): 3

Начинается новая игра

Правила игры
Цель этой игры заключается в перемещении колец с левой стороны на стержень с правой стороны.
Ход состоит в том, чтобы перенести одно кольцо на другой стержень, с условием что в пункте назначения оно самое маленькое (по размеру).
Удачи!


Текущее состояние стержней:
 1  |  | 
 2  |  | 
 3  |  | 
----
 1  2  3 

Введите номер стержня, с которого хотите переместить кольцо (1-3): 1
Введите номер стержня, на который хотите переместить кольцо (1-3): 3

Текущее состояние стержней:
 |  |  1 
 2  |  | 
 3  |  | 
----
 1  2  3 

(Далее игрок продолжает делать ходы...)

Поздравляем! Вы успешно переместили все кольца!
Минимальное количество ходов: 7
Вы сделали ходов: 7
Вы достигли оптимального решения!
```

---

## Заключение

Данная программа демонстрирует применение основных концепций программирования на языке C++, включая **определение функций**, **рекурсию** и **анализ сложности алгоритмов**. Программа позволяет игроку взаимодействовать с классической головоломкой, обеспечивая проверку правильности ходов и информируя о минимальном количестве шагов для оптимального решения.

**Особенности программы:**

- Все функции и структуры программы соответствуют представленным статьям.
- Рекурсивная функция `hanoiRecursive` реализует алгоритм решения головоломки.
- Учтена экспоненциальная сложность алгоритма `O(2^n)`.
- Пользователь самостоятельно перемещает кольца, а программа проверяет корректность действий.
- По завершении игры программа сообщает, достиг ли пользователь оптимального решения.
